// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct FactoringProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for FactoringProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = FactoringProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        FactoringProxyMethods { wrapped_tx: tx }
    }
}

pub struct FactoringProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> FactoringProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> FactoringProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> FactoringProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn add_company<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<ManagedVec<Env::Api, ManagedAddress<Env::Api>>>,
        Arg2: ProxyArg<bool>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        id_offchain: Arg0,
        administrators: Arg1,
        is_kyc: Arg2,
        withdraw_address: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addCompany")
            .argument(&id_offchain)
            .argument(&administrators)
            .argument(&is_kyc)
            .argument(&withdraw_address)
            .original_result()
    }

    pub fn create_factoring_contract<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        id_supplier: Arg0,
        id_client: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createFactoringContract")
            .argument(&id_supplier)
            .argument(&id_client)
            .original_result()
    }

    pub fn sign_contract<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("signContract")
            .argument(&id_contract)
            .original_result()
    }

    pub fn add_invoice<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<BigUint<Env::Api>>,
        Arg3: ProxyArg<u64>,
    >(
        self,
        id_contract: Arg0,
        hash: Arg1,
        amount: Arg2,
        due_date: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addInvoice")
            .argument(&id_contract)
            .argument(&hash)
            .argument(&amount)
            .argument(&due_date)
            .original_result()
    }

    pub fn confirm_invoice<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<Status>,
    >(
        self,
        id_contract: Arg0,
        id_invoice: Arg1,
        status: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("confirmInvoice")
            .argument(&id_contract)
            .argument(&id_invoice)
            .argument(&status)
            .original_result()
    }

    pub fn add_company_administrator<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        company_id: Arg0,
        new_admin: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addCompanyAdministrator")
            .argument(&company_id)
            .argument(&new_admin)
            .original_result()
    }

    pub fn fund_invoice<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        id_contract: Arg0,
        id_invoice: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("fundInvoice")
            .argument(&id_contract)
            .argument(&id_invoice)
            .original_result()
    }

    pub fn use_liquidity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("useLiquidity")
            .original_result()
    }

    pub fn exit_market_farm(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("exitMarketFarm")
            .original_result()
    }

    pub fn withdraw_liquidity(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawLiquidity")
            .original_result()
    }

    pub fn claim_farming_rewards(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("claimFarmingRewards")
            .original_result()
    }

    pub fn pay_invoice<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        id_contract: Arg0,
        id_invoice: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("payInvoice")
            .argument(&id_contract)
            .argument(&id_invoice)
            .original_result()
    }

    pub fn pay_invoice_auto<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<u64>,
    >(
        self,
        id_contract: Arg0,
        id_invoice: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("payInvoiceAuto")
            .argument(&id_contract)
            .argument(&id_invoice)
            .original_result()
    }

    pub fn add_funds(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addFunds")
            .original_result()
    }

    pub fn add_account_funds<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id_account: Arg0,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("addAccountFunds")
            .argument(&id_account)
            .original_result()
    }

    pub fn calculate_reliability_score<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("calculateReliabilityScore")
            .argument(&id_account)
            .original_result()
    }

    pub fn add_user_to_admin_list<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addUserToAdminList")
            .argument(&address)
            .original_result()
    }

    pub fn remove_user_from_admin_list<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeUserFromAdminList")
            .argument(&address)
            .original_result()
    }

    pub fn companies<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Company<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCompany")
            .argument(&id)
            .original_result()
    }

    pub fn customer_contracts<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, CustomerContract> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getCustomerContract")
            .argument(&id)
            .original_result()
    }

    pub fn invoices_by_contract<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id_contract: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, Invoice<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getInvoicesByContract")
            .argument(&id_contract)
            .original_result()
    }

    pub fn contracts_client_by_account<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getContractsClientByAccount")
            .argument(&id_account)
            .original_result()
    }

    pub fn assets_by_account_and_identifier<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        id_account: Arg0,
        identifier: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAvailableAssetByAccountAndIdentifier")
            .argument(&id_account)
            .argument(&identifier)
            .original_result()
    }

    pub fn funds_by_account<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id_account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, BigUint<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getFundsByAccount")
            .argument(&id_account)
            .original_result()
    }
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode, PartialEq, Eq, Copy, Clone)]
pub enum Status {
    PendingValidation,
    Valid,
    Funded,
    Payed,
    Refused,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct Company<Api>
where
    Api: ManagedTypeApi,
{
    pub id_offchain: u64,
    pub administrators: ManagedVec<Api, ManagedAddress<Api>>,
    pub is_kyc: bool,
    pub fee: u64,
    pub withdraw_address: ManagedAddress<Api>,
    pub reliability_score: u8,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct CustomerContract {
    pub id_supplier: u64,
    pub id_client: u64,
    pub is_signed: bool,
}

#[type_abi]
#[derive(NestedEncode, NestedDecode, TopEncode, TopDecode)]
pub struct Invoice<Api>
where
    Api: ManagedTypeApi,
{
    pub hash: ManagedBuffer<Api>,
    pub amount: BigUint<Api>,
    pub identifier: EgldOrEsdtTokenIdentifier<Api>,
    pub status: Status,
    pub due_date: u64,
    pub payed_date: Option<u64>,
}
